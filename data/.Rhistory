<<<<<<< HEAD
for (i in 1:t){
movie1<-as.matrix(unique(data[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
t
movie2
index<-which(data[,"V1.1"]==movie2)[1]
index
which(data[,"V1.1"]==movie2)
data<-read.csv("datawithnameandgenre.csv")
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"The Abyss (Special Edition)"
#if we only want to recommend the movie with the same genere
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
#######################################################
t<-length(unique(data2[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"The Abyss (Special Edition)"
#if we only want to recommend the movie with the same genere
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
#######################################################
t<-length(unique(data2[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"Brokeback Mountain"
#if we only want to recommend the movie with the same genere
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
#######################################################
t<-length(unique(data2[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
#finally we calculate the similarity of two given movies:
get_similarity <- function(movie1,movie2){
#get the common reviewer of the two movies:
id <- common_reviewers_by_id(movie1, movie2)
#in case the two movies have no common reviewers：
for (j in 1:length(id)) {
if (is.na(id[j])) {
return (NA)
break
}
}
#get the review scores of the two movies of these common users:
metrics1 <- get_review_metrics(movie1,id)
metrics2 <- get_review_metrics(movie2,id)
#regard helpfulness as the weight of every user's score
#muliple every score by its helpfulness:
product <- function(metrics){
names <- names(metrics)
temp1 <- sapply(as.matrix(metrics[names[1]]), function(x) eval(parse(text=x)))
temp2 <- sapply(as.matrix(metrics[names[2]]), function(x) eval(parse(text=x)))
temp1*temp2
}
#similarity is defined as the cosine of angle of two vectors that we get,
#The greater the cosine is, the greater the correlation is.
#the following equation if the cross product of the two vectors devided by
#the product of the vector norms
similarity <- product(metrics1)%*%product(metrics2)/(product(metrics1)%*%product(metrics1)*product(metrics2)%*%product(metrics2))^0.5
#get rid of the value 1
if (similarity == 1){
similarity = NA
}
similarity
}
#########################################
########### the implementation ##########
#########################################
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"Brokeback Mountain"
#if we only want to recommend the movie with the same genere
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
#######################################################
t<-length(unique(data2[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#record the time consumed
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
ptm
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"Brokeback Mountain"
# #if we only want to recommend the movie with the same genere
# index<-which(data[,"V1.1"]==movie2)[1]
# data2<-data[which(data[,"V2"]==data[index,"V2"]),]
# #######################################################
t<-length(unique(data2[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#record the time consumed
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
ptm
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"Brokeback Mountain"
t<-length(unique(data[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#record the time consumed
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
#finally we calculate the similarity of two given movies:
get_similarity <- function(movie1,movie2){
#get the common reviewer of the two movies:
id <- common_reviewers_by_id(movie1, movie2)
#in case the two movies have no common reviewers：
for (j in 1:length(id)) {
if (is.na(id[j])) {
return (NA)
break
}
}
#get the review scores of the two movies of these common users:
metrics1 <- get_review_metrics(movie1,id)
metrics2 <- get_review_metrics(movie2,id)
#regard helpfulness as the weight of every user's score
#muliple every score by its helpfulness:
product <- function(metrics){
names <- names(metrics)
temp1 <- sapply(as.matrix(metrics[names[1]]), function(x) eval(parse(text=x)))
temp2 <- sapply(as.matrix(metrics[names[2]]), function(x) eval(parse(text=x)))
temp1*temp2
}
#similarity is defined as the cosine of angle of two vectors that we get,
#The greater the cosine is, the greater the correlation is.
#the following equation if the cross product of the two vectors devided by
#the product of the vector norms
similarity <- product(metrics1)%*%product(metrics2)/(product(metrics1)%*%product(metrics1)*product(metrics2)%*%product(metrics2))^0.5
#get rid of the value 1
if (similarity == 1){
similarity = NA
}
similarity
}
movie1
movie1
movie2
get_similarity(movie1,movie2)
id <- common_reviewers_by_id(movie1, movie2)
#in case the two movies have no common reviewers：
for (j in 1:length(id)) {
if (is.na(id[j])) {
return (NA)
break
}
}
#get the review scores of the two movies of these common users:
metrics1 <- get_review_metrics(movie1,id)
metrics2 <- get_review_metrics(movie2,id)
#regard helpfulness as the weight of every user's score
#muliple every score by its helpfulness:
product <- function(metrics){
names <- names(metrics)
temp1 <- sapply(as.matrix(metrics[names[1]]), function(x) eval(parse(text=x)))
temp2 <- sapply(as.matrix(metrics[names[2]]), function(x) eval(parse(text=x)))
temp1*temp2
}
#similarity is defined as the cosine of angle of two vectors that we get,
#The greater the cosine is, the greater the correlation is.
#the following equation if the cross product of the two vectors devided by
#the product of the vector norms
similarity <- product(metrics1)%*%product(metrics2)/(product(metrics1)%*%product(metrics1)*product(metrics2)%*%product(metrics2))^0.5
#get rid of the value 1
if (similarity == 1){
similarity = NA
}
similarity
}
id <- common_reviewers_by_id(movie1, movie2)
#in case the two movies have no common reviewers：
for (j in 1:length(id)) {
if (is.na(id[j])) {
return (NA)
break
}
}
#get the review scores of the two movies of these common users:
metrics1 <- get_review_metrics(movie1,id)
metrics2 <- get_review_metrics(movie2,id)
#regard helpfulness as the weight of every user's score
#muliple every score by its helpfulness:
product <- function(metrics){
names <- names(metrics)
temp1 <- sapply(as.matrix(metrics[names[1]]), function(x) eval(parse(text=x)))
temp2 <- sapply(as.matrix(metrics[names[2]]), function(x) eval(parse(text=x)))
temp1*temp2
}
#similarity is defined as the cosine of angle of two vectors that we get,
#The greater the cosine is, the greater the correlation is.
#the following equation if the cross product of the two vectors devided by
#the product of the vector norms
similarity <- product(metrics1)%*%product(metrics2)/(product(metrics1)%*%product(metrics1)*product(metrics2)%*%product(metrics2))^0.5
#get rid of the value 1
if (similarity == 1){
similarity = NA
}
similarity
for (j in 1:length(id)) {
if (is.na(id[j])) {
return (NA)
break
}
}
id <- common_reviewers_by_id(movie1, movie2)
any(is.na(Id))
any(is.na(id))
id
#finally we calculate the similarity of two given movies:
get_similarity <- function(movie1,movie2){
#get the common reviewer of the two movies:
id <- common_reviewers_by_id(movie1, movie2)
#in case the two movies have no common reviewers：
if (any(is.na(id))) {
return (NA)
}else{
#get the review scores of the two movies of these common users:
metrics1 <- get_review_metrics(movie1,id)
metrics2 <- get_review_metrics(movie2,id)
#regard helpfulness as the weight of every user's score
#muliple every score by its helpfulness:
product <- function(metrics){
names <- names(metrics)
temp1 <- sapply(as.matrix(metrics[names[1]]), function(x) eval(parse(text=x)))
temp2 <- sapply(as.matrix(metrics[names[2]]), function(x) eval(parse(text=x)))
temp1*temp2
}
#similarity is defined as the cosine of angle of two vectors that we get,
#The greater the cosine is, the greater the correlation is.
#the following equation if the cross product of the two vectors devided by
#the product of the vector norms
similarity <- product(metrics1)%*%product(metrics2)/(product(metrics1)%*%product(metrics1)*product(metrics2)%*%product(metrics2))^0.5
#get rid of the value 1
if (similarity == 1){
similarity = NA
}
similarity
}
}
#now given a movie we try to find the one which has the greatest similarity to it:
movie2<-"Brokeback Mountain"
t<-length(unique(data[,"V1.1"]))
#finally we calculate the similarity of two given movies:
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
#show the name of the movie that has the highest similarity to the given movie:
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#record the time consumed
ptm <- proc.time()
###################
#Remains to improve:
#The minimum number of common users
#If we could stop the current loop as soon as we discover an NA.
ptm
#if we only focus on the movie with the same genere:
movie2<-"Brokeback Mountain"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#if we only focus on the movie with the same genere:
movie2<-"Beyond Tomorrow"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
movie2<-"Brother Sun, Sister Moon (Widescreen)"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
data<-read.csv("datawithnameandgenre.csv")
movie2<-"Brother Sun, Sister Moon (Widescreen)"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
t
index<-which(data[,"V1.1"]==movie2)[1]
index
data[9701,]
unique(data2[,"V1.1"])
t<-length(unique(data2[,"V1.1"]))
t
#if we only focus on the movie with the same genere:
movie2<-"The Last Samurai"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#if we only focus on the movie with the same genere:
movie2<-"The Last Samurai"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#if we only focus on the movie with the same genere:
movie2<-"The Ten Commandments"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
data<-read.csv("datawithnameandgenre.csv")
#if we only focus on the movie with the same genere:
movie2<-"The Ten Commandments"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
t
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
data2
data2[,"V1.1"]
unique(data2[,"V1.1"])
#if we only focus on the movie with the same genere:
#which really saves time
movie2 <- "Minority Report"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
movie2 <- "La Bamba"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
#if we only focus on the movie with the same genere:
#which really saves time
movie2 <- "Brokeback Mountain"
index<-which(data[,"V1.1"]==movie2)[1]
data2<-data[which(data[,"V2"]==data[index,"V2"]),]
t<-length(unique(data2[,"V1.1"]))
similarity <- data.frame("V1.1"=NA,"similarity"=NA)
for (i in 1:t){
movie1<-as.matrix(unique(data2[,"V1.1"]))[i]
similarity[i,1] <- movie1
similarity[i,2] <- get_similarity(movie1,movie2)
print(i)
}
similarity <- na.omit(similarity)
similarity[which.max(similarity[,2]),1]
=======
k = which.min(summary(fit21)$cp)
k
str(ex1220)
data(ex1220)
fit21 = regsubsets(Total~.,data=ex1220[,c(-1,-3)],nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
data(ex1220)
fit21 = regsubsets(Total~.,data=ex1220[,c(-1,-3)],nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
coef = names(coef(fit21,k)[-1])
coef = c("Total",coef)
data21 = ex1217[,coef]
fit11 = lm(Total~.,data21)
data21 = ex1220[,coef]
fit11 = lm(Total~.,data21)
coef
str(ex1220)
data = select(ex1220,-Island,-Native)
str(data)
fit21 = regsubsets(Total~.,data,nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
coef = names(coef(fit21,k)[-1])
coef
data = select(ex1220,-Island,-Total)
fit21 = regsubsets(Native~.,data=ex1220[,c(-1,-3)],nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
coef = names(coef(fit21,k)[-1])
data = select(ex1220,-Island,-Total)
str(data)
fit21 = regsubsets(Native~.,data=ex1220[,c(-1,-3)],nvmax=7,nbest=1,force.in = "Area")
data = select(ex1220,-Island,-Total)
fit21 = regsubsets(Native~.,data,nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
coef = names(coef(fit21,k)[-1])
coef
data = ex1220 %>%
mutate(Native = Total-Native)%>%
select(-Island,-Total)
fit21 = regsubsets(Native~.,data,nvmax=7,nbest=1,force.in = "Area")
k = which.min(summary(fit21)$cp)
coef = names(coef(fit21,k)[-1])
coef
data(ex2011)
str(ex2011)
data(ex2011)
logit3 <- glm(Failure ~ Temperature, ex2011,family = "binomial")
logit3
summary(logit3)
?wald.test
??wald.test
install.packages("aod")
library("aod")
coef(logit3)
wald.test(b = coef(logit), Sigma = vcov(logit), Terms = 2)
data(ex2011)
logit <- glm(Failure ~ Temperature, ex2011,family = "binomial")
summary(logit)
library("aod")
wald.test(b = coef(logit), Sigma = vcov(logit), Terms = 2)
?wald.test
str(ex2011)
data(ex2011)
logit <- glm(Failure ~ Temperature, ex2011,family = "binomial")
summary(logit)
pnorm(-2.053)
anova(logit)
anova(logit,test="F")
?"anova.glm"
anova(logit,test="LRT")
summary(logit)
confint.default(logit)
prob = predict.glm(logit, data.frame(Temperature = 31), type="response")
prob
prob1 = predict.glm(logit)
prob1
prob = predict.glm(logit, data.frame(Temperature = 31), type="response")
problogit = predict.glm(logit, data.frame(Temperature = 31))
problogit
data(ex2015)
str(ex2015)
?t.test
Site
attach(ex2015)
Site
attach(ex2015)
for(i in 1:7){
print("for ring", k)
t.test(ex2015[1:30,i+1],ex2015[31:60,i+1])
}
attach(ex2015)
for(i in 1:7){
print("for ring", k)
print(t.test(ex2015[1:30,i+1],ex2015[31:60,i+1]))
}
i = 1
play = t.test(ex2015[1:30,i+1],ex2015[31:60,i+1])
play$p.value
attach(ex2015)
for(i in 1:7){
print("for ring", as.character(k),"the p value is")
print(t.test(ex2015[1:30,i+1],ex2015[31:60,i+1],alternative="less")$p.value)
}
attach(ex2015)
p = vector()
for(i in 1:7){
p = c(p,t.test(ex2015[1:30,i+1],ex2015[31:60,i+1],alternative="less")$p.value)
}
p
str(eex2015)
str(ex2015)
logit = lgm(Site~.,ex2015,family = "binomial")
logit = glm(Site~.,ex2015,family = "binomial")
logit
summary(logit)
Y = c(0,0,1,1)
X = c(-2,-1,1,2)
logit = glm(Y ~ X -1, family = "binomial")
Y = factor(c(0,0,1,1))
X = c(-2,-1,1,2)
logit = glm(Y ~ X -1, family = "binomial")
logit
predict.glm(logit,data.frame(X=0.5))
predict.glm(logit,data.frame(X=0.5),type = "response")
predict.glm(logit,data.frame(X=0.5),type = "response")
beta = -50:50
logL = log(1-logit(-2*beta))+log(1-logit(-1*beta))+log(logit(1*beta))+log(logit(2*beta))
?Logit
??logit
pack = c("Sleuth3", "dplyr", "ggplot2", "car")
lapply(pack, library, character.only = TRUE)
beta = -50:50
logL = log(1-logit(-2*beta))+log(1-logit(-1*beta))+log(logit(1*beta))+log(logit(2*beta))
beta = -30:30
logL = log(1-logit(-2*beta))+log(1-logit(-1*beta))+log(logit(1*beta))+log(logit(2*beta))
beta = -25:25
logL = log(1-logit(-2*beta))+log(1-logit(-1*beta))+log(logit(1*beta))+log(logit(2*beta))
beta = 1:25
logL = log(1-logit(-2*beta))+log(1-logit(-1*beta))+log(logit(1*beta))+log(logit(2*beta))
pack = c("Sleuth3", "dplyr", "ggplot2", "car")
lapply(pack, library, character.only = TRUE)
Y = factor(c(0,0,1,1))
X = c(-2,-1,1,2)
logit = glm(Y ~ X - 1, family = "binomial")
## The maximuk likelihood of beta1 is 23.14.
## No, the estimate does not make sense.
predict.glm(logit,data.frame(X=0.5),type = "response")
## The estimate is 0.9999906.
beta = 1:25
p = function(x){
return(exp(x)/(1+exp(x)))
}
logL = log(1-p(-2*beta))+log(1-p(-1*beta))+log(p(1*beta))+log((2*beta))
plot(beta,logL)
pack = c("Sleuth3", "dplyr", "ggplot2", "car")
lapply(pack, library, character.only = TRUE)
Y = factor(c(0,0,1,1))
X = c(-2,-1,1,2)
logit = glm(Y ~ X - 1, family = "binomial")
## The maximuk likelihood of beta1 is 23.14.
## No, the estimate does not make sense.
predict.glm(logit,data.frame(X=0.5),type = "response")
## The estimate is 0.9999906.
beta = 1:30
p = function(x){
return(exp(x)/(1+exp(x)))
}
logL = log(1-p(-2*beta))+log(1-p(-1*beta))+log(p(1*beta))+log((2*beta))
pack = c("Sleuth3", "dplyr", "ggplot2", "car")
lapply(pack, library, character.only = TRUE)
Y = factor(c(0,0,1,1))
X = c(-2,-1,1,2)
logit = glm(Y ~ X - 1, family = "binomial")
## The maximuk likelihood of beta1 is 23.14.
## No, the estimate does not make sense.
predict.glm(logit,data.frame(X=0.5),type = "response")
## The estimate is 0.9999906.
beta = 1:30
p = function(x){
return(exp(x)/(1+exp(x)))
}
logL = log(1-p(-2*beta))+log(1-p(-1*beta))+log(p(1*beta))+log((2*beta))
plot(beta,logL)
setwd("~/Data Science/project4-team6/data")
library(igraph)
library(bipartite)
library(intergraph)
library(rPython)
source("https://bioconductor.org/biocLite.R")
biocLite("Biostrings")
library("seqinr")
seq1<- "What a beautiful"
seq2<- "What a"
seq1string <- tolower(seq1)
seq2string <- tolower(seq2)
library("Biostrings")
globalAlign<- pairwiseAlignment(seq1string, seq2string)
globalAlign
pid(globalAlign, type = "PID3")
globalAlign<- pairwiseAlignment(seq1string, seq2string,gapOpening=0,gapExtension=0,type="local")
globalAlign
seq1 = "What a beautiful"
seq2 = "What a"
seq3 = "What a beautiful day"
seq1string = tolower(seq1)
seq2string = tolower(seq2)
seq3string = tolower(seq3)
library("Biostrings")
globalAlign = pairwiseAlignment(seq1string, seq3string,gapOpening=0,gapExtension=0,type="local")
globalAlign
globalAlign = pairwiseAlignment(seq1string, seq4string,gapOpening=0,gapExtension=0,type="local")
seq4 = "What day"
seq1string = tolower(seq1)
seq2string = tolower(seq2)
seq3string = tolower(seq3)
seq4string = tolower(seq4)
library("Biostrings")
globalAlign = pairwiseAlignment(seq1string, seq4string,gapOpening=0,gapExtension=0,type="local")
globalAlign
globalAlign = pairwiseAlignment(seq3string, seq4string,gapOpening=0,gapExtension=0,type="local")
globalAlign
load("matData.RData")
str(matData)
movies = levels(matData$name)
?lapply
?pairwiseAlignment
Align = pairwiseAlignment(seq3string, seq4string,gapOpening=0,gapExtension=0,type="local",scoreOnly = FALSE)
Align
names(Align)
class(Align)
match = function(seq1,seq2){
seq1string = tolower(seq1)
seq2string = tolower(seq2)
Align = pairwiseAlignment(seq3string, seq4string,gapOpening=0,gapExtension=0,type="local",scoreOnly = FALSE)
return(score(Align))
}
lapply(movies,match,seq2 = "beautiful")
test = lapply(movies,match,seq2 = "beautiful")
a = c(1,2,3)
b = c(1,2)
a%in%b
system.time(test=lapply(movies,match,seq2 = "beautiful"))
system.time(lapply(movies,match,seq2 = "beautiful"))
system.time(lapply(movies,match,seq2 = "beautiful"))
length(movies)
?strsplit()
strsplit("beautiful")
strsplit("beautiful",split="")
library(dplyr)
key = "beautiful"
keyC = toCharacter(key)
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str.trim() %>%
strsplit(split="") %>%
unlist()
return(cVector)
}
keyC = toCharacter(key)
string = "beautiful"
cVector = string %>%
tolower() %>%
str.trim() %>%
strsplit(split="") %>%
unlist()
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
unlist()
library(stringr)
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
unlist()
return(cVector)
}
keyC = toCharacter(key)
moviesC = apply(movies,toCharacter)
?apply
?sapply
moviesC = sapply(movies,toCharacter)
class(moviesC)
moviesC[[1]]
?"gsub"
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
gsub(pattern="'",repacement="")
unlist()
return(cVector)
}
moviesC = sapply(movies,toCharacter)
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
gsub(pattern="'",replacement="")
unlist()
return(cVector)
}
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
moviesC[[1]]
toCharacter = function(string){
cVector = string %>%
tolower() %>%
str_trim() %>%
strsplit(split="") %>%
#gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
moviesC[[1]]
test = sapply(moviesC,`%in%`,keyC)
test[[1]]
test = keyC %in% moviesC
class(test)
test
dim(moviesC)
length(moviesC)
score = sapply(moviesC,`%in%`,keyC)
score = sapply(score,sum)
length(keyC)
plot(score)
mean(score)
?`%in%`
score = sapply(moviesC,match,x=keyC)
score = sapply(moviesC,match,x = keyC)
score = sapply(moviesC,match,keyC)
score = sapply(moviesC,`%in%`,keyC)
score[[1]]
plot(sorted(score))
plot(sort(score))
plot(score)
score = sapply(moviesC,`%in%`,keyC)
score = sapply(score,sum)
plot(sort(score))
?"quantile"
quantile(score,0.3)
length(keyC)
quantile(score,0.5)
vIn = function(s1,s2){
return(s2 %in% s1)
}
score = sapply(moviesC,vIn,keyC)
score = sapply(score,sum)
plot(score)
head(score)
score = sapply(moviesC,vIn,keyC)
score[[1]]
keyC
moviesC[[1]]
keyC %in% moviesC[[1]]
vIn = function(s1,s2){
return(c(s2 %in% s1))
}
score = sapply(moviesC,vIn,keyC)
score = sapply(score,sum)
score = sapply(moviesC[1:10],vIn,keyC)
score = sapply(score,sum)
vIn(moviesC[[1]],keyC)
score = lapply(moviesC,vIn,keyC)
score[[1]]
score = sapply(score,sum)
mean(score)
quantile(score, 0.75)
ind = score>7
head(ind)
align = function(string1,string2){
Align = pairwiseAlignment(seq3string, seq4string,gapOpening=0,gapExtension=0,type="local",scoreOnly = FALSE)
return(score(Align))
}
movies=movies[ind]
test = lapply(movies,align,key)
keyC = toCharacter(key)
score = lapply(moviesC,vIn,keyC)
score = sapply(score,sum)
ind = score>8
movies=movies[ind]
test = lapply(movies,align,key)
ind = score>8
movies=movies[ind]
test = lapply(movies,align,key)
a = "beautiful"
b = c("beautiful","heart")
a %in% b
a = c("beautiful","true","what")
a %in% b
movies[1]
toCharacter = function(string){
cVector = string %>%
tolower() %>%
gsub("[[:punct:]]", "") %>%
strsplit(split="") %>%
#gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
toCharacter = function(string){
cVector = string %>%
tolower() %>%
gsub("[[:punct:]]", "") %>%
strsplit(split=" ") %>%
#gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
```{r}
movies = levels(matData$name)
moviesC = sapply(movies,toCharacter)
library(tm)
install.packages(tm)
install.packages("tm")
library(tm)
removePunctuation("Hi!")
toCharacter = function(string){
cVector = string %>%
tolower() %>%
removePunctuation() %>%
strsplit(split=" ") %>%
#gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
moviesC = sapply(movies,toCharacter)
moviesC[1]
toWord = function(string){
cVector = string %>%
tolower() %>%
removePunctuation() %>%
strsplit(split=" ") %>%
#gsub(pattern="'",replacement="") %>%
unlist()
return(cVector)
}
key = "beautiful mind"
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
load("matData.RData")
movies = levels(matData$name)
moviesW = sapply(movies,toCharacter)
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
plot(sort(score))
a = c(4,6,2,7,8,9,10)
sort(a,partial=3)
a = c(9,3,8,1,4,3,8)
sort(a,partial=3)
?sort
ind = sort(score,partial = 5, decreasing=TRUE)
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
thresh = sort(score, decreasing=TRUE)[5]
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
thresh = sort(score, decreasing=TRUE)[5]
ind = score>thresh
movies(ind)
movies = levels(matData$name)
moviesW = sapply(movies,toCharacter)
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
thresh = sort(score, decreasing=TRUE)[5]
ind = score>thresh
movies(ind)
movies[ind]
thresh = sort(score, decreasing=TRUE)[5]
thresh
sort(score,decreasing=TRUE)[1:5]
keyW = toWord(key)
score = lapply(moviesW,vIn,keyW)
score = sapply(score,sum)
thresh = sort(score, decreasing=TRUE)[5]
ind = score>=thresh
movies[ind]
install.packages(qdap)
install.packages("qdap")
library(qdap)
x <- "Robots are evl creatres and deserv exterimanitation."
which_misspelled(x, suggest=FALSE)
which_misspelled(x, suggest=TRUE)
library(qdap)
install.packages("qdap")
library(qdap)
>>>>>>> master
